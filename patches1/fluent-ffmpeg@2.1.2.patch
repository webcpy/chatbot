diff --git a/.npmignore b/.npmignore
deleted file mode 100644
index bb1c3b14513b45d2b755eef1b4a8ed2f52e24a2f..0000000000000000000000000000000000000000
diff --git a/lib/capabilities.js b/lib/capabilities.js
index 3722ff1668fd1d79ca72fc12da3a4d9255b79c90..8aa693e52043664a719591cd8e47d4c28a183fc8 100644
--- a/lib/capabilities.js
+++ b/lib/capabilities.js
@@ -15,13 +15,13 @@ var ffCodecRegexp = /^\s*([D\.])([E\.])([VAS])([I\.])([L\.])([S\.]) ([^ ]+) +(.*
 var ffEncodersRegexp = /\(encoders:([^\)]+)\)/;
 var ffDecodersRegexp = /\(decoders:([^\)]+)\)/;
 var encodersRegexp = /^\s*([VAS\.])([F\.])([S\.])([X\.])([B\.])([D\.]) ([^ ]+) +(.*)$/;
-var formatRegexp = /^\s*([D ])([E ]) ([^ ]+) +(.*)$/;
+var formatRegexp = /^\s*([D\s*])([E\s*])\s*([^ ]+) +(.*)/;
 var lineBreakRegexp = /\r\n|\r|\n/;
 var filterRegexp = /^(?: [T\.][S\.][C\.] )?([^ ]+) +(AA?|VV?|\|)->(AA?|VV?|\|) +(.*)$/;
 
 var cache = {};
 
-module.exports = function(proto) {
+module.exports = function (proto) {
   /**
    * Manually define the ffmpeg binary full path.
    *
@@ -30,7 +30,7 @@ module.exports = function(proto) {
    * @param {String} ffmpegPath The full path to the ffmpeg binary.
    * @return FfmpegCommand
    */
-  proto.setFfmpegPath = function(ffmpegPath) {
+  proto.setFfmpegPath = function (ffmpegPath) {
     cache.ffmpegPath = ffmpegPath;
     return this;
   };
@@ -43,7 +43,7 @@ module.exports = function(proto) {
    * @param {String} ffprobePath The full path to the ffprobe binary.
    * @return FfmpegCommand
    */
-  proto.setFfprobePath = function(ffprobePath) {
+  proto.setFfprobePath = function (ffprobePath) {
     cache.ffprobePath = ffprobePath;
     return this;
   };
@@ -56,7 +56,7 @@ module.exports = function(proto) {
    * @param {String} flvtool The full path to the flvtool2 or flvmeta binary.
    * @return FfmpegCommand
    */
-  proto.setFlvtoolPath = function(flvtool) {
+  proto.setFlvtoolPath = function (flvtool) {
     cache.flvtoolPath = flvtool;
     return this;
   };
@@ -69,7 +69,7 @@ module.exports = function(proto) {
    * @method FfmpegCommand#_forgetPaths
    * @private
    */
-  proto._forgetPaths = function() {
+  proto._forgetPaths = function () {
     delete cache.ffmpegPath;
     delete cache.ffprobePath;
     delete cache.flvtoolPath;
@@ -85,16 +85,16 @@ module.exports = function(proto) {
    * @param {Function} callback callback with signature (err, path)
    * @private
    */
-  proto._getFfmpegPath = function(callback) {
+  proto._getFfmpegPath = function (callback) {
     if ('ffmpegPath' in cache) {
       return callback(null, cache.ffmpegPath);
     }
 
     async.waterfall([
       // Try FFMPEG_PATH
-      function(cb) {
+      function (cb) {
         if (process.env.FFMPEG_PATH) {
-          fs.exists(process.env.FFMPEG_PATH, function(exists) {
+          fs.exists(process.env.FFMPEG_PATH, function (exists) {
             if (exists) {
               cb(null, process.env.FFMPEG_PATH);
             } else {
@@ -107,16 +107,16 @@ module.exports = function(proto) {
       },
 
       // Search in the PATH
-      function(ffmpeg, cb) {
+      function (ffmpeg, cb) {
         if (ffmpeg.length) {
           return cb(null, ffmpeg);
         }
 
-        utils.which('ffmpeg', function(err, ffmpeg) {
+        utils.which('ffmpeg', function (err, ffmpeg) {
           cb(err, ffmpeg);
         });
       }
-    ], function(err, ffmpeg) {
+    ], function (err, ffmpeg) {
       if (err) {
         callback(err);
       } else {
@@ -137,7 +137,7 @@ module.exports = function(proto) {
    * @param {Function} callback callback with signature (err, path)
    * @private
    */
-  proto._getFfprobePath = function(callback) {
+  proto._getFfprobePath = function (callback) {
     var self = this;
 
     if ('ffprobePath' in cache) {
@@ -146,9 +146,9 @@ module.exports = function(proto) {
 
     async.waterfall([
       // Try FFPROBE_PATH
-      function(cb) {
+      function (cb) {
         if (process.env.FFPROBE_PATH) {
-          fs.exists(process.env.FFPROBE_PATH, function(exists) {
+          fs.exists(process.env.FFPROBE_PATH, function (exists) {
             cb(null, exists ? process.env.FFPROBE_PATH : '');
           });
         } else {
@@ -157,29 +157,29 @@ module.exports = function(proto) {
       },
 
       // Search in the PATH
-      function(ffprobe, cb) {
+      function (ffprobe, cb) {
         if (ffprobe.length) {
           return cb(null, ffprobe);
         }
 
-        utils.which('ffprobe', function(err, ffprobe) {
+        utils.which('ffprobe', function (err, ffprobe) {
           cb(err, ffprobe);
         });
       },
 
       // Search in the same directory as ffmpeg
-      function(ffprobe, cb) {
+      function (ffprobe, cb) {
         if (ffprobe.length) {
           return cb(null, ffprobe);
         }
 
-        self._getFfmpegPath(function(err, ffmpeg) {
+        self._getFfmpegPath(function (err, ffmpeg) {
           if (err) {
             cb(err);
           } else if (ffmpeg.length) {
             var name = utils.isWindows ? 'ffprobe.exe' : 'ffprobe';
             var ffprobe = path.join(path.dirname(ffmpeg), name);
-            fs.exists(ffprobe, function(exists) {
+            fs.exists(ffprobe, function (exists) {
               cb(null, exists ? ffprobe : '');
             });
           } else {
@@ -187,7 +187,7 @@ module.exports = function(proto) {
           }
         });
       }
-    ], function(err, ffprobe) {
+    ], function (err, ffprobe) {
       if (err) {
         callback(err);
       } else {
@@ -207,16 +207,16 @@ module.exports = function(proto) {
    * @param {Function} callback callback with signature (err, path)
    * @private
    */
-   proto._getFlvtoolPath = function(callback) {
+  proto._getFlvtoolPath = function (callback) {
     if ('flvtoolPath' in cache) {
       return callback(null, cache.flvtoolPath);
     }
 
     async.waterfall([
       // Try FLVMETA_PATH
-      function(cb) {
+      function (cb) {
         if (process.env.FLVMETA_PATH) {
-          fs.exists(process.env.FLVMETA_PATH, function(exists) {
+          fs.exists(process.env.FLVMETA_PATH, function (exists) {
             cb(null, exists ? process.env.FLVMETA_PATH : '');
           });
         } else {
@@ -225,13 +225,13 @@ module.exports = function(proto) {
       },
 
       // Try FLVTOOL2_PATH
-      function(flvtool, cb) {
+      function (flvtool, cb) {
         if (flvtool.length) {
           return cb(null, flvtool);
         }
 
         if (process.env.FLVTOOL2_PATH) {
-          fs.exists(process.env.FLVTOOL2_PATH, function(exists) {
+          fs.exists(process.env.FLVTOOL2_PATH, function (exists) {
             cb(null, exists ? process.env.FLVTOOL2_PATH : '');
           });
         } else {
@@ -240,27 +240,27 @@ module.exports = function(proto) {
       },
 
       // Search for flvmeta in the PATH
-      function(flvtool, cb) {
+      function (flvtool, cb) {
         if (flvtool.length) {
           return cb(null, flvtool);
         }
 
-        utils.which('flvmeta', function(err, flvmeta) {
+        utils.which('flvmeta', function (err, flvmeta) {
           cb(err, flvmeta);
         });
       },
 
       // Search for flvtool2 in the PATH
-      function(flvtool, cb) {
+      function (flvtool, cb) {
         if (flvtool.length) {
           return cb(null, flvtool);
         }
 
-        utils.which('flvtool2', function(err, flvtool2) {
+        utils.which('flvtool2', function (err, flvtool2) {
           cb(err, flvtool2);
         });
       },
-    ], function(err, flvtool) {
+    ], function (err, flvtool) {
       if (err) {
         callback(err);
       } else {
@@ -294,37 +294,44 @@ module.exports = function(proto) {
    * @param {FfmpegCommand~filterCallback} callback callback function
    */
   proto.availableFilters =
-  proto.getAvailableFilters = function(callback) {
-    if ('filters' in cache) {
-      return callback(null, cache.filters);
-    }
-
-    this._spawnFfmpeg(['-filters'], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {
-      if (err) {
-        return callback(err);
+    proto.getAvailableFilters = function (callback) {
+      if ('filters' in cache) {
+        return callback(null, cache.filters);
       }
 
-      var stdout = stdoutRing.get();
-      var lines = stdout.split('\n');
-      var data = {};
-      var types = { A: 'audio', V: 'video', '|': 'none' };
-
-      lines.forEach(function(line) {
-        var match = line.match(filterRegexp);
-        if (match) {
-          data[match[1]] = {
-            description: match[4],
-            input: types[match[2].charAt(0)],
-            multipleInputs: match[2].length > 1,
-            output: types[match[3].charAt(0)],
-            multipleOutputs: match[3].length > 1
-          };
+      this._spawnFfmpeg(['-filters'], {
+        captureStdout: true,
+        stdoutLines: 0
+      }, function (err, stdoutRing) {
+        if (err) {
+          return callback(err);
         }
-      });
 
-      callback(null, cache.filters = data);
-    });
-  };
+        var stdout = stdoutRing.get();
+        var lines = stdout.split('\n');
+        var data = {};
+        var types = {
+          A: 'audio',
+          V: 'video',
+          '|': 'none'
+        };
+
+        lines.forEach(function (line) {
+          var match = line.match(filterRegexp);
+          if (match) {
+            data[match[1]] = {
+              description: match[4],
+              input: types[match[2].charAt(0)],
+              multipleInputs: match[2].length > 1,
+              output: types[match[3].charAt(0)],
+              multipleOutputs: match[3].length > 1
+            };
+          }
+        });
+
+        callback(null, cache.filters = data);
+      });
+    };
 
 
   /**
@@ -350,80 +357,91 @@ module.exports = function(proto) {
    * @param {FfmpegCommand~codecCallback} callback callback function
    */
   proto.availableCodecs =
-  proto.getAvailableCodecs = function(callback) {
-    if ('codecs' in cache) {
-      return callback(null, cache.codecs);
-    }
-
-    this._spawnFfmpeg(['-codecs'], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
-      if (err) {
-        return callback(err);
+    proto.getAvailableCodecs = function (callback) {
+      if ('codecs' in cache) {
+        return callback(null, cache.codecs);
       }
 
-      var stdout = stdoutRing.get();
-      var lines = stdout.split(lineBreakRegexp);
-      var data = {};
-
-      lines.forEach(function(line) {
-        var match = line.match(avCodecRegexp);
-        if (match && match[7] !== '=') {
-          data[match[7]] = {
-            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[3]],
-            description: match[8],
-            canDecode: match[1] === 'D',
-            canEncode: match[2] === 'E',
-            drawHorizBand: match[4] === 'S',
-            directRendering: match[5] === 'D',
-            weirdFrameTruncation: match[6] === 'T'
-          };
+      this._spawnFfmpeg(['-codecs'], {
+        captureStdout: true,
+        stdoutLines: 0
+      }, function (err, stdoutRing) {
+        if (err) {
+          return callback(err);
         }
 
-        match = line.match(ffCodecRegexp);
-        if (match && match[7] !== '=') {
-          var codecData = data[match[7]] = {
-            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[3]],
-            description: match[8],
-            canDecode: match[1] === 'D',
-            canEncode: match[2] === 'E',
-            intraFrameOnly: match[4] === 'I',
-            isLossy: match[5] === 'L',
-            isLossless: match[6] === 'S'
-          };
-
-          var encoders = codecData.description.match(ffEncodersRegexp);
-          encoders = encoders ? encoders[1].trim().split(' ') : [];
-
-          var decoders = codecData.description.match(ffDecodersRegexp);
-          decoders = decoders ? decoders[1].trim().split(' ') : [];
-
-          if (encoders.length || decoders.length) {
-            var coderData = {};
-            utils.copy(codecData, coderData);
-            delete coderData.canEncode;
-            delete coderData.canDecode;
-
-            encoders.forEach(function(name) {
-              data[name] = {};
-              utils.copy(coderData, data[name]);
-              data[name].canEncode = true;
-            });
+        var stdout = stdoutRing.get();
+        var lines = stdout.split(lineBreakRegexp);
+        var data = {};
+
+        lines.forEach(function (line) {
+          var match = line.match(avCodecRegexp);
+          if (match && match[7] !== '=') {
+            data[match[7]] = {
+              type: {
+                'V': 'video',
+                'A': 'audio',
+                'S': 'subtitle'
+              } [match[3]],
+              description: match[8],
+              canDecode: match[1] === 'D',
+              canEncode: match[2] === 'E',
+              drawHorizBand: match[4] === 'S',
+              directRendering: match[5] === 'D',
+              weirdFrameTruncation: match[6] === 'T'
+            };
+          }
 
-            decoders.forEach(function(name) {
-              if (name in data) {
-                data[name].canDecode = true;
-              } else {
+          match = line.match(ffCodecRegexp);
+          if (match && match[7] !== '=') {
+            var codecData = data[match[7]] = {
+              type: {
+                'V': 'video',
+                'A': 'audio',
+                'S': 'subtitle'
+              } [match[3]],
+              description: match[8],
+              canDecode: match[1] === 'D',
+              canEncode: match[2] === 'E',
+              intraFrameOnly: match[4] === 'I',
+              isLossy: match[5] === 'L',
+              isLossless: match[6] === 'S'
+            };
+
+            var encoders = codecData.description.match(ffEncodersRegexp);
+            encoders = encoders ? encoders[1].trim().split(' ') : [];
+
+            var decoders = codecData.description.match(ffDecodersRegexp);
+            decoders = decoders ? decoders[1].trim().split(' ') : [];
+
+            if (encoders.length || decoders.length) {
+              var coderData = {};
+              utils.copy(codecData, coderData);
+              delete coderData.canEncode;
+              delete coderData.canDecode;
+
+              encoders.forEach(function (name) {
                 data[name] = {};
                 utils.copy(coderData, data[name]);
-                data[name].canDecode = true;
-              }
-            });
+                data[name].canEncode = true;
+              });
+
+              decoders.forEach(function (name) {
+                if (name in data) {
+                  data[name].canDecode = true;
+                } else {
+                  data[name] = {};
+                  utils.copy(coderData, data[name]);
+                  data[name].canDecode = true;
+                }
+              });
+            }
           }
-        }
-      });
+        });
 
-      callback(null, cache.codecs = data);
-    });
-  };
+        callback(null, cache.codecs = data);
+      });
+    };
 
 
   /**
@@ -452,38 +470,45 @@ module.exports = function(proto) {
    * @param {FfmpegCommand~encodersCallback} callback callback function
    */
   proto.availableEncoders =
-  proto.getAvailableEncoders = function(callback) {
-    if ('encoders' in cache) {
-      return callback(null, cache.encoders);
-    }
-
-    this._spawnFfmpeg(['-encoders'], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {
-      if (err) {
-        return callback(err);
+    proto.getAvailableEncoders = function (callback) {
+      if ('encoders' in cache) {
+        return callback(null, cache.encoders);
       }
 
-      var stdout = stdoutRing.get();
-      var lines = stdout.split(lineBreakRegexp);
-      var data = {};
-
-      lines.forEach(function(line) {
-        var match = line.match(encodersRegexp);
-        if (match && match[7] !== '=') {
-          data[match[7]] = {
-            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[1]],
-            description: match[8],
-            frameMT: match[2] === 'F',
-            sliceMT: match[3] === 'S',
-            experimental: match[4] === 'X',
-            drawHorizBand: match[5] === 'B',
-            directRendering: match[6] === 'D'
-          };
+      this._spawnFfmpeg(['-encoders'], {
+        captureStdout: true,
+        stdoutLines: 0
+      }, function (err, stdoutRing) {
+        if (err) {
+          return callback(err);
         }
-      });
 
-      callback(null, cache.encoders = data);
-    });
-  };
+        var stdout = stdoutRing.get();
+        var lines = stdout.split(lineBreakRegexp);
+        var data = {};
+
+        lines.forEach(function (line) {
+          var match = line.match(encodersRegexp);
+          if (match && match[7] !== '=') {
+            data[match[7]] = {
+              type: {
+                'V': 'video',
+                'A': 'audio',
+                'S': 'subtitle'
+              } [match[1]],
+              description: match[8],
+              frameMT: match[2] === 'F',
+              sliceMT: match[3] === 'S',
+              experimental: match[4] === 'X',
+              drawHorizBand: match[5] === 'B',
+              directRendering: match[6] === 'D'
+            };
+          }
+        });
+
+        callback(null, cache.encoders = data);
+      });
+    };
 
 
   /**
@@ -508,47 +533,50 @@ module.exports = function(proto) {
    * @param {FfmpegCommand~formatCallback} callback callback function
    */
   proto.availableFormats =
-  proto.getAvailableFormats = function(callback) {
-    if ('formats' in cache) {
-      return callback(null, cache.formats);
-    }
-
-    // Run ffmpeg -formats
-    this._spawnFfmpeg(['-formats'], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {
-      if (err) {
-        return callback(err);
+    proto.getAvailableFormats = function (callback) {
+      if ('formats' in cache) {
+        return callback(null, cache.formats);
       }
 
-      // Parse output
-      var stdout = stdoutRing.get();
-      var lines = stdout.split(lineBreakRegexp);
-      var data = {};
-
-      lines.forEach(function(line) {
-        var match = line.match(formatRegexp);
-        if (match) {
-          match[3].split(',').forEach(function(format) {
-            if (!(format in data)) {
-              data[format] = {
-                description: match[4],
-                canDemux: false,
-                canMux: false
-              };
-            }
-
-            if (match[1] === 'D') {
-              data[format].canDemux = true;
-            }
-            if (match[2] === 'E') {
-              data[format].canMux = true;
-            }
-          });
+      // Run ffmpeg -formats
+      this._spawnFfmpeg(['-formats'], {
+        captureStdout: true,
+        stdoutLines: 0
+      }, function (err, stdoutRing) {
+        if (err) {
+          return callback(err);
         }
-      });
 
-      callback(null, cache.formats = data);
-    });
-  };
+        // Parse output
+        var stdout = stdoutRing.get();
+        var lines = stdout.split(lineBreakRegexp);
+        var data = {};
+
+        lines.forEach(function (line) {
+          var match = line.match(formatRegexp);
+          if (match) {
+            match[3].split(',').forEach(function (format) {
+              if (!(format in data)) {
+                data[format] = {
+                  description: match[4],
+                  canDemux: false,
+                  canMux: false
+                };
+              }
+
+              if (match[1] === 'D') {
+                data[format].canDemux = true;
+              }
+              if (match[2] === 'E') {
+                data[format].canMux = true;
+              }
+            });
+          }
+        });
+
+        callback(null, cache.formats = data);
+      });
+    };
 
 
   /**
@@ -560,21 +588,21 @@ module.exports = function(proto) {
    * @param {Function} callback callback with signature (err)
    * @private
    */
-  proto._checkCapabilities = function(callback) {
+  proto._checkCapabilities = function (callback) {
     var self = this;
     async.waterfall([
       // Get available formats
-      function(cb) {
+      function (cb) {
         self.availableFormats(cb);
       },
 
       // Check whether specified formats are available
-      function(formats, cb) {
+      function (formats, cb) {
         var unavailable;
 
         // Output format(s)
         unavailable = self._outputs
-          .reduce(function(fmts, output) {
+          .reduce(function (fmts, output) {
             var format = output.options.find('-f', 1);
             if (format) {
               if (!(format[0] in formats) || !(formats[format[0]].canMux)) {
@@ -593,7 +621,7 @@ module.exports = function(proto) {
 
         // Input format(s)
         unavailable = self._inputs
-          .reduce(function(fmts, input) {
+          .reduce(function (fmts, input) {
             var format = input.options.find('-f', 1);
             if (format) {
               if (!(format[0] in formats) || !(formats[format[0]].canDemux)) {
@@ -614,16 +642,16 @@ module.exports = function(proto) {
       },
 
       // Get available codecs
-      function(cb) {
+      function (cb) {
         self.availableEncoders(cb);
       },
 
       // Check whether specified codecs are available and add strict experimental options if needed
-      function(encoders, cb) {
+      function (encoders, cb) {
         var unavailable;
 
         // Audio codec(s)
-        unavailable = self._outputs.reduce(function(cdcs, output) {
+        unavailable = self._outputs.reduce(function (cdcs, output) {
           var acodec = output.audio.find('-acodec', 1);
           if (acodec && acodec[0] !== 'copy') {
             if (!(acodec[0] in encoders) || encoders[acodec[0]].type !== 'audio') {
@@ -641,7 +669,7 @@ module.exports = function(proto) {
         }
 
         // Video codec(s)
-        unavailable = self._outputs.reduce(function(cdcs, output) {
+        unavailable = self._outputs.reduce(function (cdcs, output) {
           var vcodec = output.video.find('-vcodec', 1);
           if (vcodec && vcodec[0] !== 'copy') {
             if (!(vcodec[0] in encoders) || encoders[vcodec[0]].type !== 'video') {
